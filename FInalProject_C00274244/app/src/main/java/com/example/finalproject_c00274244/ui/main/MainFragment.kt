package com.example.finalproject_c00274244.ui.main

//Alec Hebert
//C00274244
//CMPS 359: Android Programming
//Final Programming Project
//Certificate of Authenticity: I certify that the code in this project are entirely my own
//work or were caused to be generated by me.
//Description: This is an application meant to use a Room database to retain entries about
//user-input game reviews. The user will be able to delete, filter, and add entries. Entries
//will consist of username, game, rating (Double, min 0.0, max 100.0), pros, and cons.

import android.app.Application
import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteDatabase.openOrCreateDatabase
import androidx.lifecycle.ViewModelProviders
import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.lifecycle.Observer
import androidx.navigation.Navigation
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.finalproject_c00274244.*
import kotlinx.android.synthetic.main.main_fragment.*


class MainFragment : Fragment() {
    private var adapter: EntryListingAdapter? = null
    companion object {
        fun newInstance() = MainFragment()
    }

    private lateinit var viewModel: MainViewModel

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View {

        return inflater.inflate(R.layout.main_fragment, container, false)

    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        viewModel = ViewModelProviders.of(this).get(MainViewModel::class.java)
        next.setOnClickListener{
            val user = username.text.toString()
            val videoGame = game.text.toString()
            val score: String
            if(rating.text.toString() == "" || rating.text.toString().toDouble() > 100.0 || rating.text.toString().toDouble()<0.0) {
                score = "-100.0"
            } else score = rating.text.toString()
            //val pros = "dummypros"
            //val cons = "dummycons"
            //If every textbox has data:
            if(user != "" && videoGame != "" && score.toDouble() != -100.0){
                //val anEntry = Entry(0, user, videoGame, score, pros, cons)
                //viewModel.insertEntry(anEntry)
                var action: MainFragmentDirections.ActionMainFragmentToProsFragment = MainFragmentDirections.actionMainFragmentToProsFragment()
                action.setUsername(user)
                action.setGame(videoGame)
                action.setRating(score)
                clearDataEntryFields()
                Navigation.findNavController(it).navigate(action)
            }else{
                clearSearchFields()
                filterRes.setText("An entry field has an invalid value. (Your rating can only range from 0.0 to 100.0. Username and game name cannot be empty.)")
            }
        }
        delete.setOnClickListener{
            viewModel.deleteEntry(username.text.toString(), game.text.toString())
            clearDataEntryFields()
            clearSearchFields()
        }
        search.setOnClickListener{
            viewModel.findEntry(game.text.toString(), username.text.toString())
        }
        viewModel.getAllEntries()?.observe(viewLifecycleOwner, Observer{
            it?.let{
                adapter?.setEntryList(it)
            }
        })
        //***This is where we choose what is displayed where when search is clicked.***
        viewModel.getSearchResults().observe(viewLifecycleOwner, Observer{
            it?.let{
                if(it.isNotEmpty()){
                    filterRes.setText(it[0].username + " gave " + it[0].game + " a rating of " + it[0].rating + " out of 100.")
                    filterPros.setText("Pros: " + it[0].pros)
                    filterCons.setText("Cons: " + it[0].cons)
                } else{
                    clearSearchFields()
                    filterRes.setText("Match not Found. :(")
                }
            }
        })
        adapter = EntryListingAdapter(R.layout.entry_list_item)
        var recyclerView: RecyclerView? = entryListing
        recyclerView?.layoutManager = LinearLayoutManager(this.context)
        recyclerView?.adapter = adapter
    }
    private fun clearDataEntryFields(){
        username.setText("")
        game.setText("")
        rating.setText("")
    }
    private fun clearSearchFields(){
        filterRes.setText("")
        filterPros.setText("")
        filterCons.setText("")
    }
    override fun onResume(){
        super.onResume()
        clearDataEntryFields()
        clearSearchFields()
    }
        //For testing the database stuff:


        //This is just the boilerplate of Room Tutorial Part 1's find button. Applied to the UI's
        //search button as a placeholder. dindexvalue and eindexvalue added to show game and rating.
        //next.setOnClickListener {
            //val entry = Entry(
                //0,
                //username.text.toString(),
                //game.text.toString(),
                //rating.text.toString().toDouble(),
                //"dummypros",
                //"dummycons"
            //)
            //entryRepository?.insertEntry(entry)
            //username.text.clear()
            //game.text.clear()
            //rating.text.clear()
            //After entering username, game, and rating, go to prosFragment to enter pros and cons.
            //For now, the person can input any value for the text boxes, but it will do nothing until
            //I get to coding that part.
            //Potential Solution: Pass username, game, and rating as arguments to prosFragment.
            //Navigation.findNavController(it)
                //.navigate(R.id.action_mainFragment_to_prosFragment)
        //}
        //search.setOnClickListener {
            //try {
                //val curse = db!!.rawQuery("SELECT * FROM entries", null)
                //val cindexkey = curse.getColumnIndex("id")
                //val cindexvalue = curse.getColumnIndex("username")
                //val dindexvalue = curse.getColumnIndex("game")
                //val eindexvalue = curse.getColumnIndex("rating")
                //curse.moveToFirst()
                //var message = "No match!"
                //if (curse.count > 0) {
                    //message = ""
                    //do {
                        //message = message + "(" + curse.getString(cindexkey) +
                                //"," + curse.getString(cindexvalue) + ","+
                                //curse.getString(dindexvalue) + ","+
                                //curse.getString(eindexvalue) +")\n"
                    //} while (curse.moveToNext())
                    //entryListing!!.text = message
                //}
            //} catch (e: Exception) {
                //entryListing!!.text = e.toString()
            //}
        //}

}